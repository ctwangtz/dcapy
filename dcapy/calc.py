"""
Decision Curve Analysis

Author: Matthew Black
"""

import pandas as pd
import numpy as np


def initialize_result_dataframes(event_rate, thresh_lb, thresh_ub, thresh_step):
    """Initializes the net_benefit and interventions_avoided dataFrames for the
    given threshold boundaries and event rate

    Parameters
    ----------
    event_rate : float
    thresh_lb : float
    thresh_ub : float
    thresh_step : float

    Returns
    -------
    pd.DataFrame, pd.DataFrame
        properly initialized net_benefit, interventions_avoided dataframes
    """
    #initialize threshold series for each dataFrame
    net_benefit = pd.Series(frange(thresh_lb, thresh_ub+thresh_step, thresh_step),
                            name='threshold')
    interventions_avoided = pd.DataFrame(net_benefit)

    #construct 'all' and 'none' columns for net_benefit
    net_benefit_all = event_rate - (1-event_rate)*net_benefit/(1-net_benefit)
    net_benefit_all.name = 'all'
    net_benefit = pd.concat([net_benefit, net_benefit_all], axis=1)
    net_benefit['none'] = 0

    return net_benefit, interventions_avoided


def calc_tf_positives(data, outcome, predictor, net_benefit_threshold, j):
    """Calculate the number of true/false positives for the given parameters

    Parameters
    ----------
    data : pd.DataFrame
        the data set to analyze
    outcome : str
        the column of the data frame to use as the outcome
    predictor : str
        the column to use as the predictor for this calculation
    net_benefit_threshold : pd.Series
        the threshold column of the net_benefit data frame
    j : int
        the index in the net_benefit data frame to use

    Returns
    -------
    tuple(float, float)
        the number of true positives, false positives
    """
    true_positives = false_positives = 0
    #create a filter mask
    filter_mask = data[predictor] >= net_benefit_threshold[j]
    filter_mask_sum = filter_mask.sum()
    if filter_mask_sum == 0:
        pass
    else:
        #get all outcomes where the filter_mask is 'True'
        filtered_outcomes = map(lambda x,y: x if y == True else np.nan,
                                data[outcome],filter_mask)
        filtered_outcomes = [outcome for outcome in filtered_outcomes
                             if outcome is not np.nan]  #drop all NaN values
        true_positives = mean(filtered_outcomes)*filter_mask_sum
        false_positives = (1-mean(filtered_outcomes))*filter_mask_sum

    return true_positives, false_positives


def calculate_net_benefit(index, net_benefit_threshold, harm,
                          true_positives, false_positives, num_observations):
    """Calculates the net benefit for an index within the construction of net_benefit
    loop

    This function calculates the net_benefit for a particular predictor at the given index, however
    the predictor doesn't need to be supplied to this function and should already be determined
    from the true/false positive calculation

    NOTE: true/false positives should be generated by using the calc_tf_positives
    function for the predictor of interest

    Parameters
    ----------
    net_benefit_threshold : pd.Series
        the 'threshold' column of the net_benefit dataframe for the analysis
    harm : float
        the harm value for the predictor
    true_positives : float
        the number of true positives for the given predictor
    false_positives : float
        the number of false positives for the given predictor
    num_observations : int
        the number of observations in the data set
    index : int
        the index in the Series to compute for

    Returns
    -------
    float
        value for the net benefit at 'index' for the predictor
    """
    #normalize the true/false positives by the number of observations
    tp_norm = true_positives/num_observations
    fp_norm = false_positives/num_observations
    #calculate the multiplier for the false positives
    multiplier = net_benefit_threshold[index]/(1-net_benefit_threshold[index])

    return tp_norm - fp_norm*multiplier - harm


def calculate_interventions_avoided(predictor, net_benefit, intervention_per,
                                    interventions_avoided_threshold):
    """Calculate the interventions avoided for the given predictor

    Parameters
    ----------
    predictor : str
        the predictor to calculate for
    net_benefit : pd.DataFrame
        the net benefit dataframe for the analysis
    intervention_per : int
        TODO
    interventions_avoided_threshold : pd.Series
        the 'threshold' column of the interventions_avoided dataframe

    Returns
    -------
    pd.Series
        the number of interventions avoided for this predictor
    """
    net_benefit_factor = net_benefit[predictor] - net_benefit['all']
    interv_denom = (interventions_avoided_threshold/(1-interventions_avoided_threshold))

    return net_benefit_factor * intervention_per/interv_denom


def frange(start, stop, step):
    """Generator that can create ranges of floats

    See: http://stackoverflow.com/questions/7267226/range-for-floats

    Parameters
    ----------
    start : float
       the minimum value of the range
    stop : float
        the maximum value of the range
    step : float
        the step between values in the range

    Yields
    ------
    float
        the next number in the range `start` to `stop`-`step`
    """
    while start < stop:
        yield start
        start += step


def mean(iterable):
    """Calculates the mean of the given iterable

    Parameters
    ----------
    iterable: int, float
        an iterable of ints or floats

    Returns
    -------
    float
        the arithmetic mean of the def __iter__(self):
    return iter()able
    """
    return sum(iterable)/len(iterable)
